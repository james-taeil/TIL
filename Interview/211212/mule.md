# 프로그램, 프로세스, 스레드
프로그램 : 메모리 단계에 올라가지 않았지만 실행 할 수 있는 파일
프로세스 : 실행 중인 프로그램 (프로그램 인스턴스)
스레드 : 프로세스에서 공간을 받아서 실질적으로 실행하는 단위

차이 : 프로세스는 자신만의 고유 공간과 자원을 할당받아 사용하는데 반해, 스레드는 다른 스레드와 공간, 자원을 공유하면서 사용하는 차이가 존재함

# 스레드에서 가장 많이 나타나는 문제
Critical Section

동기화 문제 

해결책 ?
mutes(하나의 프로세스 or 스레드 대해서 어떻게 스케줄링을 할 것 인가? => waiting, sleep), semafo

# 파이썬 GIL
Critical Section => 

파이썬 GIL => 레거시로 남아졋다

# 프로세스가 생성 될 때 메모리가 어떤식으로 할당 받게 되는가?(OS)
Code : 코드 자체를 구성하는 메모리 영역(프로그램 명령)

Data : 전역변수, 정적변수, 배열 등

초기화 된 데이터는 data 영역에 저장
초기화 되지 않은 데이터는 bss 영역에 저장

Heap : 동적 할당 시 사용 (new(), malloc() 등)
```js
let arr = new Array(4); // heap에서 size 4만큼 잡히는 배열
let arr2 = []; // stack에서 잡히는 고정배열
```

Stack : 지역변수, 매개변수, 리턴 값

스레드는 Stack만 따로 할당 받고 나머지 영역은 서로 공유

# 런타임
컴파일 언어 기준으로 
컴파일 타임 : 컴파일 할 때, 메모리 산정하고 등등 (컴파일 하는 과정) 
런타임 : 컴파일 한 것을 실행하는 과정

# 컴파일타임 런타임 메모리 할당 등 ... 공부 필요

# 메모리 잡을 때, 가상주소(Virtual Memory) 사용하는 이유
RAM에서 3개의 메모리 공간을 확보했다고 가정하자
컴퓨터에서는 RAM에 확보된 메모리 공간만큼 프로세스를 실행시키지만 여기서 1개를 더 실행 시킨다면 ?
메모리 공간의 물리적인 주소는 부족할 것이다.
이를 해결하기 위해 가상주소를 사용한다.
프로세스 3개의 메모리에 할당 된 프로세스가 전부 실행 중에 한개를 더 실행 시킨다면 당연히 못하겠지만, 대부분 이렇지는 않다.
A, B, C가 각각 가상 주소를 할당 받고, 실행 중에 D가 실행 되었다면, A, B, C 중 실행되지 않는 메모리 공간 중 물리적인 주소를 찾아 그곳에 가상 주소를 mapping 해준다. 즉, 쉬고 있는 메모리 공간을 찾아 사용을 하는 것이다.
이렇게 된다면, 더 많은 프로세스를 실행 할 수 있다.

# python에 everthing is an object라는 말이 있다. 다른 언어와 차이점
배우기 쉽다, 하지만 느리다

```c
int a = 4;
```
C언어에서는 `4`라는 **값**의 주소로 할당 되어 있다.

```py
a = 4 # 
```
python에서는 `4`라는 **객체**에 할당 되었다고 한다.
사용자 입장에서는 편하지만, 컴퓨터 입장에서는 성능이 느리게 되는 이유이다.

python은 4를 할당 해줄 때, 데이터를 할당하는 과정에서 pointer를 통해 한 단계 더 들어간다.
결론적으로 입력하는 값은 `4`, `hello world`라는 값이지만 이것이 `pyobject`라는 객체를 통해 pointer를 통해 들억가기 때문에 사용자 입장에서는 타입지정 없고, 메모리를 얼마나 할당 할 것인지 지정을 안하게 되어 편하지만, 컴퓨터의 측면에서는 성능 저하로 된다.

# list vs array 장단점, 차이점
list : value(개념적으로 봤을 때는 객체라고 생각 할 수 있다.), pointer

메모리 적으로 생각해 보자

array : 배열 공간에 value가 할당

index, pointer가 주 keyword

탐색만에 과정에서는 Array가 성능적으로 더 빠르다.
하지만, 다른과정에서는 그렇다고 무조건적으로 생각 할 수 없다.
예를들어, value가 100만개 쯤 되는 값으로 들어가 있는 array와 list가 있다고 가정하자
10만번쨰 값을 지워야 하면, 어떻게 작동 할까?
array는 탐색하는 과정을 통해 10만번째는 금방 찾겠지만, array에 중간에 값이 비어있으면 절대 안된다.(기본적으로) 그래서 10만번째를 지우고 뒤에잇는 약 90만개의 value를 앞으로 당겨야 한다.
하지만 list는 탐색은 조금 걸리겠지만, 삭제하는 과정에서는 pointer만 바꿔주면 되기 때문에 더 빠르다.


# python list vs numpy
python list는 list 안에 value가 어떻게 들어오는지 모른다. 즉, 위에서 말햇던 것 처럼 **객체**다.
```py
arr = [1, 'a', {}]
```
이런식으로 값 하나에 `pyobject`를 통해 한단계 더 들어가 데이터가 저장된다.

하지만 numpy는 list안에 value가 같은 데이터로 통일된다.
그렇게 되면, **객체**를 통해 list 값이 통째로 들어있는 공간을 만들기 때문에 성능적으로 높은 성능을 기대 할 수 있다.
그리고 numpy는 c wapper이다. (내부적으로 코드를 깠을 때 C언어이다)

# stack vs queue를 구현하는데 있어서 list vs array
stack은 array, queue는 list 하지만 아직은 `모른다`라고 버거형님들이 말해줌
시간적인 것이랑 공간적인 것을 고려해야 되기 때문이다.

# call by value vs call by reference
call by value : 다른 주소값을 가지고 있는 식별자(값의 의한 호출)
call by reference : 같은 주소값을 가지고 있는 식별자(참조의 의한 호출)

# python mutable vs immutable
```py
a = 1
b = 2
print(a, b)
print(id(a), id(b))

def foo(a, b):
    a += 1
    b += 1
    return a + b
foo(a, b)

print(a, b)
print(id(a), id(b))
```

```py
a = [1]
b = [2]
print(a, b)
print(id(a), id(b))

def foo(a, b):
    a += [1]
    b += [1]
    return  a + b

foo(a, b)
print(a, b)
print(id(a), id(b))
```

위 코드와 아래 코드의 차이점은 가변성과 불변성을 나뉜다. ~~실행해보면 안다~~

# OOP
객체 지향 프로그래밍
OOP 특징은 무엇인가?
OOP 3요소 - 다형성, 캡슐화, 상속성
OOP 원칙 - SOLID


그럼 객체는 무엇인가?
class : 
object : 
instence : 

왜 OOP?
재사용성

다형성 : 여러개의 형태를 가질 수 있다. overloading(같은 역할을 할 수 있게 설계), overriding(부모의 기능 + 자식의 기능)
캡슐화 : 퍼블릭, 프라이빗(은닉성)
상속성 : 부모의 특성 자식이 가져와 사용 할 수 있다.(A is B !== B is A)

consturctor : 언제 실행? 왜 사용?

# abstract vs interface
abstract class : 자식이 기능을 가질 때, 모든 기능을 부모에서 설정해 줄 수없으므로, 추상적으로 부모class에서 선언만 해준다 라는 느낌?
interface class : abstract class보다 추상화 정도가 높고, abstract class와 상수만 멤버로 가질 수 있다는 특징이 있다.


차이점 : 추성화에는 상속을 가진다. vs interface에서는 has의 개념 (일부이다 느낌, 가지고 있다.)
차를 예시로 들자면, 차마다 드라이브, 브레이크 기능은 있다. 세부적으로 다를뿐 : 추상 하지만
인터페이스는 파츠 느낌이 강하다. 차에서 바퀴는 휠, 타이어등 계속 바꿔 낄 수 있다.

# extends vs implements
extends : SOLID 원칙으로 하나만 하는 것을 선호한다. 부모의 메소드를 그대로 사용할 수 있으며 오버라이딩 할 필요 없이 부모에 구현되있는 것을 직접 사용 가능하다.
implements : 하지만 다중상속을 원하는 경우가 있다. 이때를 위해 implements를 만들었다. implements의 가장 큰 특징은 이렇게 부모의 메소드를 반드시 오버라이딩해야 한다.
```java
public class Son implements Father, Mother{...}
```

# SOLID 원칙
Single Responsibility Principle(단일책임원칙) : 작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는 데 집중되어 있어야 한다는 원칙
Open Close Principle(개방폐쇄의 원칙) : 소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야 한다는 원리
he Liskov Substitution Principle(리스코브 치환의 원칙) : LSP를 한마디로 한다면, “서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.”라고 할 수 있다. 즉, 서브 타입은 언제나 기반 타입과 호환될 수 있어야 한다.
nterface Segregation Principle(인터페이스 분리의 원칙) : 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원리. 즉 어떤 클래스가 다른 클래스에 종속될 때에는 가능한 최소한의 인터페이스만을 사용
Dependency Inversion Principle(의존성역전의 원칙) : 의존 관계의 역전 Dependency Inversion 이란 구조적 디자인에서 발생하던 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 위계관계를 끊는 의미의역전. 실제 사용 관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고 받음으로써 관계를 최대한 느슨하게 만드는 원칙.

# fw vs lib
lib : set of function => 내가 원하는데로 사용하는 것
fw : lib + @(흐름, 형식, 규약) => 따르는 것

라이브러리 : 여러개 쓸 수 있어
프레임워크 : 여러개 쓰진 않아

왜?
흐름? 규약? 이 있다?
프레임워크 : 흐름에 대한 형식이 어느정도 가지고 있다.
라이브러리 : 이런 기능은 여기서 쓰면 된다.